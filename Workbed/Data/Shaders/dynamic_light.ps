#include "PBL_Functions.hlsl"
cbuffer per_frame : register(b0)
{
	row_major float4x4 InvertedProjection; 
	row_major float4x4 InvertedView; 
};

cbuffer per_object : register(b1)
{
	float4 color;
	float4 position;
	float4 cam_pos;
	row_major float4x4 shadowMVP;
#ifdef SPOTLIGHT
    float4 direction;
#endif
};


struct psInput
{
	float4 pos	: SV_POSITION;
#ifdef SPOTLIGHT
	float4 normal : NORMAL;
#endif
	float4 uv	: POSITION;
	float range : RANGE;
#ifdef SPOTLIGHT
	float cosAngle : COSANGLE;
    float angle : ANGLE;
	float intensity : INTENSITY;
	float4 world : WORLD;
#endif
};

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.0f - 1.0f;
	float y = (1.0f - tex_coord.y) * 2.0f - 1.0f;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.0f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, InvertedView);
    return world_pos;
}

float4 main(psInput input) : SV_Target
{
	#ifdef POINTLIGHT
return float4(0,0,0,0);
	#endif
   	input.uv /= input.uv.w;
	float2 texCoord = input.uv.xy;

    float4 albedo = AlbedoTexture.Sample(sampler0, texCoord);
	float4 normal = NormalTexture.Sample(sampler0, texCoord);
	float4 depth = DepthTexture.Sample(sampler0, texCoord);
	float metalness = normal.w;
	float roughness = depth.y;
	
	normal *= 2;
	normal -= 1;
	
	float4 world_pos = getWorldPos(texCoord, depth.r);


#ifdef SPOTLIGHT

	float3 _temp_lightdir = normalize(input.world.xyz - position.xyz);
	float3 _V = normalize(cam_pos.xyz - input.world.xyz);
	float ndotl = dot(-_temp_lightdir, normal.xyz);
	return ndotl.xxxx;

	float3 _L = normalize(position.xyz - input.world.xyz);


	float LdLD = dot(_L, -_temp_lightdir);

	float _spotscale = pow(max(LdLD, 0), 8);
	return _spotscale.xxxx;

	return float4(_L, 1);


#endif







    float4 final_color = 1;

	float3 _pos = position.xyz;
	float3 _worldpos = world_pos.xyz;

	float3 lightToPixel = _worldpos - _pos;
	float3 toLight = _pos - _worldpos;
	float ln = length(toLight);
	float3 light_dir = toLight / ln; //normalize(toLight);
	#ifdef SPOTLIGHT

	float n = dot(light_dir, normal);
	return n.xxxx;
	return float4(light_dir, 1);
	#endif
    float NdL = saturate(dot(normal.xyz, light_dir));



	float3 to_eye = normalize(cam_pos.xyz - _worldpos);	
	float3 halfVec = normalize(light_dir + to_eye);

	float HdN = saturate(dot(halfVec, normal));
	float NdV = saturate(dot(normal, to_eye));

	int nMips = 0;
	int width = 0;
	int height = 0;
	CubeMap.GetDimensions(0, width, height, nMips);

	half roughnessOffsetted = pow(roughness, 8192);
	half lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips);
	float3 refVec = normalize(reflect(to_eye.xyz, normal.xyz));
	half4 reflection_fresnel = half4(ReflectionFresnel(albedo.rgb, normal.xyz, to_eye, roughnessOffsetted), 1);
	float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);

	float4 cube = CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * reflection_fresnel;
	float4 cube_ambient = CubeMap.SampleLevel(sampler1, normal, lysMipMap) * metalness_albedo * (1 - reflection_fresnel);
	cube_ambient = saturate(cube_ambient);
	float4 diffuse = 0;
	albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);
	diffuse += float4( ( NdL * 1 / PI)  * color * albedo.rgb, 1.0f);
	
	float4 fresnel = saturate(Fresnel(metalness_albedo, float4(light_dir.xyz, 1), float4(halfVec, 1)));
	float Distr = saturate(D_GGX(HdN, roughness));
	float V = saturate(V_SchlickForGGX(roughness, NdV, NdL));
	float4 spec = 0;

	float attenuation = 0;
	float intensity = 1;
#ifdef SPOTLIGHT

    float cosCone = input.cosAngle ;
	float3 lightVec = normalize(lightToPixel);
	float spotfactor = dot(lightVec, -light_dir);
	
	return spotfactor.xxxx;

	if(spotfactor < cosCone)
		discard;

	float angularAttenuation = ( 1.0 - ( 1.0 - spotfactor) *  1 / ( 1 - cosCone)) ;
	float linearAttenuation = CalculateTotalAttenuation(ln, input.range) ;
	return angularAttenuation.xxxx;
	attenuation = linearAttenuation * angularAttenuation ;
	spec += saturate((((fresnel * Distr * V) * NdL) * color) );	
	// intensity = input.intensity;
#endif

#ifdef POINTLIGHT
	return float4(0,0,0,0);
	attenuation = CalculateTotalAttenuation(ln, input.range) * 2;
	spec += saturate((((fresnel * Distr * V) * NdL) * color) );
#endif
	diffuse += cube_ambient * albedo;
	diffuse = saturate(diffuse);
	float4 output = 0;
	output = lerp(diffuse, cube, fresnel);
	output += spec;
	output = saturate(output);

	
	return (output * attenuation) * intensity;

};
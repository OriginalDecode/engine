

cbuffer per_frame : register (b0)
{
	row_major float4x4 InvertedProjection;
	row_major float4x4 View;
};

cbuffer Ambient : register(b1)
{
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
	float4 viewDir;
	float4 camPos;
};

SamplerState sampler0 : register (s0); // Trilinear
SamplerState sampler1 : register (s1); // Cubemap
SamplerState sampler2 : register (s2); // Bilinear

Texture2D AlbedoTexture 	: register (t0);
Texture2D NormalTexture  	: register (t1);
Texture2D Emissive  	: register (t4);
Texture2D DepthTexture	 	: register (t7);
Texture2D ShadowTexture		: register (t8);
TextureCube CubeMap		 	: register (t9);
Texture2D SSAOTexture		: register (t10);
TextureCube CubeMap2		 	: register (t11);


struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

static const float k0 = 0.00098,
				k1 = 0.9921; 
static const float specMax = (2 / (0.0014 * 0.0014)) - 2;
static const float g_MaxT = exp2(-10 / sqrt(specMax) - k0) / k1;
static const float PI = 3.14159265;

// GGX Specular
// Source: http://www.filmicworlds.com/images/ggx-opt/optimized-ggx.hlsl

float RoughToSPow(float fRoughness)
{
	return (2.h / (fRoughness * fRoughness)) - 2.h;
}

float GetSpecPowToMip(float fSpecPow, int nMips)
{
	float fSmulMaxT = (exp2(-10 / sqrt(fSpecPow)) - k0) / k1;
	return float(nMips - 1) * (1 - clamp(fSmulMaxT / g_MaxT, 0.0, 1.0));
}

float3 ReflectionFresnel(const float3 substance, const float3 light_dir, const float3 half_vec, float roughness)
{
	float LdotH = saturate(dot(light_dir, half_vec));
	LdotH = 1.0f - LdotH;
	LdotH = max(0, min(pow(LdotH, 5), 1)); //max(0, min(pow(LdotH, 5), 1));
	float3 fresnel = LdotH * (1.f - substance);
	fresnel = fresnel / (6 - 5 * roughness);
	fresnel = substance + fresnel;
	return fresnel;
}

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, View);
    return world_pos;
}
// http://orsvarn.com/post/pbr-shader-source/
// Source: https://github.com/godotengine/godot/blob/df573f5c3a76155842e43ea0dbab594e3944b114/drivers/gles3/shaders/scene.glsl

float3 OrenNayarBRDF(float NdL, float NdV, float LdV, float roughness, float3 albedo)
{
	float s = LdV - NdL * NdV;
	float t = lerp(1.0, max(NdL, NdV), step(0.0, s));

	float r2 = roughness * roughness;

	float3 A = 1.0 + r2 * (- 0.5 / (r2 + 0.33) + 0.17 * albedo / (r2 + 0.13) ); //(albedo / ( r2 / (r2 + 0.13) + 0.5 / (r2 + 0.33 ) ) );
	float3 B = 0.45 * r2 / (r2 + 0.09);

	albedo = albedo * max(0.0, NdL) * (A + B * s / t) / 3.14;

	return albedo;
}

float3 CookTorranceBRDF(float D, float3 F, float G, float ndl, float ndv)
{
	float3 f = D * F * G;
	f = f / ( 4  * ndl * ndv);
	return f;
}

//Schlick-GGX, Geometric Shadowing (G) , Smith schlick-GGX.
float Geometric_Smith_Schlick_GGX(float r, float ndv, float ndl)
{
	float k = (r * r) * 0.5f;
	float GV = ndv / (ndv * (1 - k) + k);
	float GL = ndl / (ndl * (1 - k) + k);
	return GV * GL;
}

// GGX (Trowbridge-Reitz) (D) Normal Distribution Function , NDF
float D_GGX(float HdN, float r) 
{
	float m = r*r;
	float m2 = m*m;
	float Denominator = HdN*HdN*(m2 - 1.f) + 1.f;
	float D = m2 / (3.14159*Denominator*Denominator);
	return D;
}

//f0 = reflectance at normal incidence (F)
float3 Fresnel(float fVdH, float3 f0)
{
	float VdH = 1 - fVdH;
	VdH = pow(VdH, 5);

	float3 F =  f0 + ( 1 - f0);
	F *= VdH;	
	return F;
}

float3 fresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)
{
	float fRough = 1 - roughness;
	return F0 + (max(float3(fRough, fRough, fRough), F0) - F0) * pow(1 - cosTheta, 5);
}

float SchlickFresnel(float u)
{
	float m = clamp(1-u, 0, 1);
	float m2 = m*m;
	return m2*m2*m;
}

float2 poissonDisk[16] = { 
   float2( -0.94201624, -0.39906216 ), 
   float2( 0.94558609, -0.76890725 ), 
   float2( -0.094184101, -0.92938870 ), 
   float2( 0.34495938, 0.29387760 ), 
   float2( -0.91588581, 0.45771432 ), 
   float2( -0.81544232, -0.87912464 ), 
   float2( -0.38277543, 0.27676845 ), 
   float2( 0.97484398, 0.75648379 ), 
   float2( 0.44323325, -0.97511554 ), 
   float2( 0.53742981, -0.47373420 ), 
   float2( -0.26496911, -0.41893023 ), 
   float2( 0.79197514, 0.19090188 ), 
   float2( -0.24188840, 0.99706507 ), 
   float2( -0.81409955, 0.91437590 ), 
   float2( 0.19984126, 0.78641367 ), 
   float2( 0.14383161, -0.14100790 ) 
};


float4 main(VS_OUTPUT input) : SV_Target
{
	float4 camera_position = camPos; //View._m30_m31_m32_m33;


	int nMips = 0, width = 0, height = 0;
	CubeMap.GetDimensions(0, width, height, nMips);


	

	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);
	float4 base_col = float4(albedo.rgb, 1);
	float4 depth = DepthTexture.Sample(sampler0, input.uv);
	
	float roughness = 1 - depth.y;
	float metalness = depth.z;
	
	float roughnessOffsetted = pow(roughness, 8192);
	float lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips);


	normal *= 2;
	normal -= 1;

	float3 light_dir = -light_direction.xyz;
    float NdL = max(0,dot(normal.xyz, -light_dir));

    float4 pixel_pos = getWorldPos(input.uv, 1 - depth.x);
	float4 to_eye = normalize(camera_position - pixel_pos);

	float3 half_vec = normalize(light_dir - to_eye); // / length(light_dir + viewDir);
	float HdotN = dot(half_vec, normal);
	float NdV = dot(normal, to_eye); 
	float LdV = dot(light_dir, to_eye);
	float VdH = saturate(dot(to_eye, half_vec));


	float3 refVec = normalize(reflect(-to_eye.xyz, normal.xyz));

	// float4 metalness_albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);
	//float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);
	float4 metalness_albedo = albedo - albedo * metalness;
	float4 substance = (0.04 - 0.04 * metalness) + albedo * metalness;



	float4 newPos = pixel_pos + (normal * 0.4);
	newPos.w = 1;
	float4 shadowVec = mul(newPos, ShadowMVP);
	shadowVec.xyz /= shadowVec.w;
	shadowVec.y = -shadowVec.y;
	shadowVec.x = shadowVec.x;
	shadowVec.xy += 1;
	shadowVec.xy *= 0.5;

	float compareValue = shadowVec.z;

 	float visibility = 1; 
	for(int i = 0; i < 4; i++)
	{
		int index = i;
		visibility -= 0.4 * (1 - ShadowTexture.Sample(sampler2, shadowVec.xy + poissonDisk[index] / 700 ).r);
	}

	float sampleValue =  ShadowTexture.Sample(sampler2, shadowVec.xy).r;


	// visibility -= 0.2*( 1.0 - texture( shadowMap, vec3(ShadowCoord.xy + poissonDisk[index]/700.0,  (ShadowCoord.z-bias)/ShadowCoord.w) ));

	const bool in_view = (shadowVec.x < 0 || shadowVec.x > 1 || shadowVec.y > 1 || shadowVec.y < 0);
	const bool in_shadow = (sampleValue < compareValue); 

	float4 reflection_fresnel = float4(ReflectionFresnel(substance.rgb, normal.xyz, to_eye, 1 - roughnessOffsetted), 1);
	
	float4 radiance = CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * reflection_fresnel;
	float3 irradiance = CubeMap.SampleLevel(sampler1, normal, nMips).rgb * metalness_albedo.rgb * ( 1 - reflection_fresnel.rgb);

	float4 ambient = float4(irradiance,1) + radiance;
	float albedoLum = 0.3 * albedo.r + 0.6 * albedo.g + albedo.b * 0.1; 
	float3 albedoTint = albedoLum > 0 ? albedo.rgb / albedoLum : float3(1,1,1); 

	ambient.rgb *= albedoTint;
	// ambient *= in_shadow ? 0.22 : 1;
	ambient.a = 1;


	float4 diffuse = 0;// metalness_albedo * cube_ambient2;
	float4 spec = 0;
	float3 light_col = float3(1, 1.0, 1.0);
	float light_intensity = 1;
	float rough2 = roughness * roughness;
	float rough2half = rough2 / 2;


	float D = D_GGX(HdotN, roughness );
	float3 F = Fresnel(VdH, substance.rgb);
	float G = Geometric_Smith_Schlick_GGX((1 - roughness) / 2, VdH, NdL);
	float3 cook = CookTorranceBRDF(D,F,G, NdL, NdV);

	float3 directDiffuse = 0, directSpec = 0;
	
	//if(!in_shadow)
	{	
		directDiffuse = (saturate(( 1-F ) * NdL * metalness_albedo ) );
		directSpec = (saturate(F * D * G) * NdL * light_col );
	}


	//return float4(directSpec,1);

	float4 final = float4(saturate(ambient.rgb + directDiffuse + directSpec), 1)  * float4(light_col, 1);

	return final;

	return saturate(ambient); //* albedoLum;

	return reflection_fresnel;

	// float4 irradiance = CubeMap.SampleLevel(sampler1, normal, lysMipMap) * reflection_fresnel;// * metalness_albedo * (  reflection_fresnel);

	float3 kS = Fresnel(NdV, metalness_albedo.rgb);
	float3 kD = 1 - kS;
	float3 _diffuse = irradiance.rgb * albedo.rgb;
	float3 _ambient = (kD * _diffuse) * 1; // 1 should be AO
	// float3 kS = fresnelSchlickRoughness(NdL, F0);


	//DISNEY

	float LdotH = dot(light_dir, half_vec);

	float FL = SchlickFresnel(NdL), FV = SchlickFresnel(NdV);
	float Fd90 = 0.5 + 2 * (LdotH * LdotH) * roughness;
	float Fd = albedoTint * lerp(1, Fd90, FL) * lerp(1, Fd90, FV);



	float Fss90 = LdotH * LdotH * roughness;
	float Fss = lerp(1, Fss90, FL) * lerp(1, Fss90, FV);
	float ss = 1.25 * (Fss * (1 / (NdL  + NdV) - 0.5) + 0.5);


	// float ax = max(0.0001, sqrt)

	return saturate(lerp(Fd, ss, 0) * (1 / PI) * albedo);

	return (1 /PI) * lerp(Fd, ss, 0) * ( 1 - metalness);



	// return metalness_albedo;



	//return base_col * dot(normal.rgb, light_dir);
	float3 oren = OrenNayarBRDF(NdL, NdV, LdV, roughness, albedo.rgb);

	return float4(oren, 1);

	

	
	float3 dif = albedo.rgb / 3.14;


	float3 cFinal = float3(1,1,1) * NdL * ( dif * ( 1 - cook) + cook);
	return float4(cFinal, 1);

	
	float LdH = saturate(dot(light_dir, half_vec));
	LdH = 1 - LdH;
	LdH = pow(LdH, 5);
	float4 schlickFresnel = LdH * ( 1 - metalness_albedo);
	schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
	schlickFresnel = metalness_albedo + schlickFresnel;
	//F


	for(int i = 0; i < 0; i++)
	{
		// diffuse
		//diffuse += float4( ( NdL * (1 / PI))  *  albedo.rgb, 1.0f);		
		//spec
		float HdN = saturate(dot(half_vec, normal));
		
		float m = rough2;
		float m2 = m*m;
		float denominator = HdN * HdN * (m2 - 1) + 1;
		
		float ggxDistr = m2 / (PI * denominator * denominator); //D
		
		float SchlickGGXGeo = (NdV / (NdV * (1 - rough2half ) + rough2half)); //G
		
		float k = rough2half;
		float G1V = NdV * ( 1.f - k ) + k;
		float G1L = NdL * ( 1.f - k ) + k;
		float V = 0.25f / (G1V * G1L);

		spec += schlickFresnel;
		spec *= ggxDistr;
		spec *= V;
		spec *= NdL;
		spec *= float4(light_col, 1);
		spec *= light_intensity;

		//spec += saturate(((schlickFresnel * ggxDistr * V) * float4(light_col, 1)) * light_intensity) * NdL;
	}
	
//	diffuse += active_cube[0] * albedo;

	float4 output = 0;
	output = diffuse; //lerp(diffuse, cube, schlickFresnel);
	output += spec;
	return saturate(output);

	
};




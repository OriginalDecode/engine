
cbuffer Spotlight : register( b0 )
{
	row_major float4x4 InvertedProjection; 
	row_major float4x4 InvertedView; 
	float4 color;
	float4 position;
	float4 camPosition;
	row_major float4x4 shadowMVP;
    float4 direction;
};

Texture2D ShadowTexture	 : register ( t8 );
Texture2D ParticleTexture : register ( t5 );

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION;
	float4 uv	: POSITION;
	float2 cosAngle : COSANGLE;
    float2 range : RANGE;
};

struct gsOut
{
    float4 m_Position : SV_POSITION;
	float4 uv : TEXCOORD;
    float m_InterpolDist : DISTANCE;
	float range : RANGE;
};

float DegreeToRad(float aDegree)
{
	return aDegree = aDegree * (3.1415926535f / 180);
};

float RadToDegree(float aRadian)
{
	return aRadian = aRadian * (180 / 3.1415926535f);
};

#include "PBL_Functions.hlsl"
float4 main(gsOut input) : SV_Target
{
	float4 col = color;
	input.uv /= input.uv.w;
	float2 texCoord = input.uv.xy;

	DeferredPixelData data = CalculateDeferredPixelData(texCoord);
	LightVectors vectors = CalculateLightVectors(data, camPosition, position);
	
	float3 F = saturate(Fresnel(data.substance, -vectors.light_dir, vectors.halfVec));
	float3 D = saturate(D_GGX(vectors.HdotN,(data.roughness ) / 2.f));
	float3 V = saturate(V_SchlickForGGX((data.roughness ) / 2.f, vectors.NdotV, vectors.NdotL));

	float cosCone = cos(DegreeToRad(53.f)) / 2;//input.cosAngle.x;
    float3 lightToPixel = normalize(-vectors.toLight);
    float spotFactor = max(0, dot(lightToPixel, normalize(direction)));

	float angularAttenuation = (1 - (1 - spotFactor) * ( 1 / ( 1 - cosCone))) / 2;

	float ln = length(vectors.toLight);
	float attenuation = max(0, CalculateTotalAttenuation(ln, input.range));

	col.a = 1;
	float3 directSpec = float3(1,1,1) + (D * F * V);
	float3 final_color = saturate( directSpec * ((attenuation * angularAttenuation) * col)) * 100;

	float4 newPos = data.world_pos + (data.normal * 0.4);
	newPos.w = 1;
	float4 shadowVec = mul(newPos, shadowMVP);
	shadowVec.xyz /= shadowVec.w;
	shadowVec.y = -shadowVec.y;
	shadowVec.x = shadowVec.x;
	shadowVec.xy += 1;
	shadowVec.xy *= 0.5;

	float compareValue = shadowVec.z;

	float sampleValue = ShadowTexture.Sample(point_Clamp, shadowVec.xy).x;
	float4 output = float4(final_color, 1);
	float4 lighToEye = normalize(camPosition - position);
	float lightToSurfaceAngle = dot(lighToEye, direction);
	if(lightToSurfaceAngle > cosCone)
		output += float4(color.rgb, 1) * attenuation * angularAttenuation;


	return output;
};
cbuffer per_frame : register(b0)
{
	row_major float4x4 InvertedProjection; 
	row_major float4x4 InvertedView; 
}

cbuffer Spotlight : register( b1 )
{
	float4 color;
	float4 light_pos;
	float4 camPosition;
	row_major float4x4 shadowMVP;
    float4 direction;
};

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION;
	float4 uv	: POSITION;
	float2 cosAngle : COSANGLE;
    float range : RANGE;
    float angle : ANGLE;
};

float CalculateAttenuation(float someDistance)
{
	float attenuation = 1.f / (1.f + 0.1f * someDistance + 0.01f * someDistance * someDistance);
	return attenuation;
};

float CalculateFalloff(float someDistance, float someRange)
{
	float fallOff = 0.9f - (someDistance / (someRange + 0.00001f));
	return fallOff;
};

float CalculateTotalAttenuation(float someDistance, float someRange)
{
	float totalAttenuation = CalculateAttenuation(someDistance) * CalculateFalloff(someDistance, someRange);
	return totalAttenuation;
};


SamplerState sampler0 	 : register (s0);
Texture2D AlbedoTexture  : register (t0);
Texture2D NormalTexture  : register (t1);
Texture2D DepthTexture	 : register (t7);


float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, InvertedView);
    return world_pos;
}

float4 main(VS_OUTPUT input) : SV_Target
{
	input.uv /= input.uv.w;
	float2 texCoord = input.uv.xy;

	float4 diffuse = AlbedoTexture.Sample(sampler0, texCoord);
	float4 normal = NormalTexture.Sample(sampler0, texCoord) * 2 - 1;
	float4 depth = DepthTexture.Sample(sampler0, texCoord);
	
	
	float4 world_pos = getWorldPos(texCoord, depth.r);

	float cosCone = input.cosAngle.x ;
	float angle = input.angle;


	float4 light_vec = light_pos - world_pos; 
	float4 light_dir =  normalize(direction);
    float3 toPixel = normalize(light_vec);
    float spotFactor = dot(toPixel, -light_dir);
	float ln = length(light_vec);

	if(input.range < ln)
		discard;

	float ndl = dot(-toPixel, normal);

	float angularAttenuation =     (1 - spotFactor) *  (1 / ( 1 - cosCone)) / 2   ;
	float attenuation = max(0, CalculateTotalAttenuation(ln, input.range));
	
	float spot = pow(max(dot(-toPixel, light_dir),0), 1);
	float att = spot / dot(1.f, float3(1.0, ln, ln*ln));


	return spot * att ;



};
cbuffer per_frame : register(b0)
{
	row_major float4x4 InvertedProjection; 
	row_major float4x4 InvertedView; 
}

cbuffer Spotlight : register( b1 )
{
	float4 color;
	float4 light_pos;
	float4 camPosition;
	row_major float4x4 shadowMVP;
    float4 direction;
};

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION;
	float4 uv	: POSITION;
	float2 cosAngle : COSANGLE;
    float range : RANGE;
    float angle : ANGLE;
	float4 world : WORLD;
};

float CalculateAttenuation(float someDistance)
{
	float attenuation = 1.f / (1.f + 0.1f * someDistance + 0.01f * someDistance * someDistance);
	return attenuation;
};

float CalculateFalloff(float someDistance, float someRange)
{
	float fallOff = 0.9f - (someDistance / (someRange + 0.00001f));
	return fallOff;
};

float CalculateTotalAttenuation(float someDistance, float someRange)
{
	float totalAttenuation = CalculateAttenuation(someDistance) * CalculateFalloff(someDistance, someRange);
	return totalAttenuation;
};


SamplerState sampler0 	 : register (s0);
Texture2D AlbedoTexture  : register (t0);
Texture2D NormalTexture  : register (t1);
Texture2D DepthTexture	 : register (t7);


float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, InvertedView);
    return world_pos;
}

float4 main(VS_OUTPUT input) : SV_Target
{
	input.uv /= input.uv.w;
	float2 texCoord = input.uv.xy;

	float4 diffuse = AlbedoTexture.Sample(sampler0, texCoord);
	float4 normal = NormalTexture.Sample(sampler0, texCoord) * 2 - 1;
	float4 depth = DepthTexture.Sample(sampler0, texCoord);
	
	
	float4 world_pos = getWorldPos(texCoord, depth.r);

	float cosCone = input.cosAngle.x ;
	float angle = input.angle;


	float4 light_dir =  normalize(direction);
	float4 light_vec = light_pos - world_pos; 
    float3 toPixel = normalize(light_vec);
    float spotFactor = dot(toPixel, -light_dir);
	float ln = length(light_vec);





	if(spotFactor < cosCone)
		discard;

	float ndl = dot(-toPixel, normal);

	float angularAttenuation = ( 1.0 - ( 1.0 - spotFactor) *  1 / ( 1 - cosCone));
	//float attenuation = max(0, CalculateTotalAttenuation(ln, input.range));

	float falloff = 0.9 - (ln / max(input.range, 0.000001));
	float _att = saturate(1.f * falloff);

	float attenuation = _att * angularAttenuation; 
	
	return attenuation * 20;



	float4 final_color = float4(1,0,0,1);
	final_color = saturate(ndl * final_color);
	final_color *= 10.f;
	final_color *= diffuse;
	final_color *= attenuation;


	return final_color;



	
	//float spot = pow(max(dot(-toPixel, light_dir),0), 1);
	//float att = spot / dot(1.f, float3(1.0, ln, ln*ln));





};
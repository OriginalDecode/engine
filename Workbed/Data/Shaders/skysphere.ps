SamplerState sampler0 : register ( s0 );
Texture2D DepthTexture : register ( t7 );

struct VS_OUTPUT
{
	float4 pos 		: SV_POSITION;
	float2 tex 		: TEXCOORD;
};

cbuffer per_frame : register (b0)
{
	row_major float4x4 InvertedProjection;
	row_major float4x4 View;
};

cbuffer data : register ( b2 )
{
	float4 m_ViewDir;
	float4 m_ViewPos;
	float4 m_LightDir;
	float4 filler;
};

static const int iSteps = 16;
static const int jSteps = 8;
static const float PI = 3.141592;

float2 RayVsSphere(float3 ray_origo, float3 ray_dir, float sphere_radius)
{
	const float a = dot(ray_dir, ray_dir);

	const float b = 2.f * dot(ray_dir, ray_origo);
	const float c = dot(ray_origo, ray_origo) - (sphere_radius * sphere_radius);
	const float d = (b * b) - 4.f * a * c;

	if (d < 0.0)
		return float2(1e5, -1e5);

	const float x = (-b - sqrt(d) ) / (2.f * a);
	const float y = (-b + sqrt(d) ) / (2.f * a);

	return float2(x, y);
};

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, View);
    return world_pos;
}


float3 calculate_reileigh()
{
	return float3(0,0,0);
}

float3 calculate_mie()
{
	return float3(0,0,0);
}

float calculate_stepSize(float3 view_dir, float3 view_pos, float atmosphere_radius, float planet_radius)
{
	float2 p = RayVsSphere(view_pos, view_dir, atmosphere_radius);

	if (p.x > p.y)
		return 0.0;

	float2 c = RayVsSphere(view_pos, view_dir, planet_radius);
	p.y = min(p.y, c.x);

	return (p.y - p.x) / float(iSteps);
	
}



float3 atmosphere(float3 view_dir, float3 view_pos, float3 light_dir,
				float sun_intensity, float planet_radius, float atmosphere_radius,
				float3 rayleigh_coef, float mie_coef,
				float rayleigh_scale_height, float mie_scale_height, float distr)
{

	float iStepSize = calculate_stepSize(view_dir, view_pos, atmosphere_radius, planet_radius);

	float iTime = 0.0;
	float3 totalRlh, totalMie; 	//total rayleigh & mie contribution
	float iOdRlh, iOdMie;		//optical distribution
	iOdMie = iOdRlh = 0.0;

	float mu = dot(view_dir, light_dir);
	float mu2 = mu*mu;
	float dist2 = distr * distr;

	float pRlh = 3.0 / (16.0 * PI) * (1.0 + mu2); // rayleigh phase func
	float pMie = 3.0 / (8.0 * PI) * ((1.0 - dist2) * (mu2 + 1.0)) / (pow(1.0 + dist2 - 2.0 * mu * distr, 1.5) * (2.0 + dist2)); // mie phase func

	for (int i = 0; i < iSteps; i++)
	{
		float3 iPos = view_pos + view_dir * (iTime + iStepSize * 0.5);
		int iHeight = length(iPos) - planet_radius;

		float odStepRlh = exp(-iHeight / rayleigh_scale_height) * iStepSize; //becomes 0
		float odStepMie = exp(-iHeight / mie_scale_height) * iStepSize; // becomes 0

		iOdRlh += odStepRlh;
		iOdMie += odStepMie;

		float jStepSize = RayVsSphere(iPos, light_dir, atmosphere_radius).y / float(jSteps);
		float jTime = 0.0;

		float jOdRlh = 0.0;
		float jOdMie = 0.0;

		for (int j = 0; j < jSteps; j++)
		{
			float3 jPos = iPos + light_dir * (jTime + jStepSize * 0.5);
			float jHeight = length(jPos) - planet_radius;

			jOdRlh += exp(-jHeight / rayleigh_scale_height) * jStepSize;
			jOdMie += exp(-jHeight / mie_scale_height) * jStepSize;
			jTime += jStepSize;
		}

		float attenX = exp(-(mie_coef * (iOdMie + jOdMie) + rayleigh_coef.x * (iOdRlh + jOdRlh)));
		float attenY = exp(-(mie_coef * (iOdMie + jOdMie) + rayleigh_coef.y * (iOdRlh + jOdRlh)));
		float attenZ = exp(-(mie_coef * (iOdMie + jOdMie) + rayleigh_coef.z* (iOdRlh + jOdRlh)));

		float3 atten;
		atten.x = attenX;
		atten.y = attenY;
		atten.z = attenZ;

		totalRlh = totalRlh + (odStepRlh * atten);
		totalMie = totalMie + (odStepMie * atten);

		iTime += iStepSize;

	}

	return ((pRlh * rayleigh_coef * totalRlh)  + (pMie * mie_coef * totalMie)) * sun_intensity; 
};

float4 main(VS_OUTPUT input) : SV_Target
{
	// float4 tex = input.tex;
	// input.tex /= input.tex.w;
	float2 texCoord = input.tex.xy;	
	float depth = 1 - (DepthTexture.Sample(sampler0, texCoord).r);

	const float3 rsc = float3(5.5e-6, 13.0e-6, 22.4e-6); 	// rayleigh scatter coefs
	const float msc = 21e-6; 								// mie scatter coef
	const float rsh = 8e3; 								// rayleigh scale height
	const float msh = 1.2e3; 								// mie scale height
	const float sunI = 10.0; 								// intensity of the sun
	const float rPlanet = 6370e3;
	const float rAtmosphere = 6471e3;
	const float distr_factor = 0.758;
	
	float3 new_pos = m_ViewPos.xyz;
	new_pos.y += rPlanet;


	float3 world_pos = getWorldPos(texCoord, depth);
	float3 view_dir = normalize(world_pos - m_ViewPos);
	float3 light_dir = normalize(m_LightDir.xyz);

/* float3 atmosphere(
				float3 view_dir, 
				float3 view_pos, 
				float3 light_dir,
 				float sun_intensity, 
				float planet_radius,
				float atmosphere_radius,
 				float3 rayleigh_coef, 
				float mie_coef,
 				float rayleigh_scale_height, 
				float mie_scale_height, 
				float distr
				)
*/

	float dist = distance(world_pos, new_pos);
	


	float3 col = atmosphere(view_dir, new_pos, light_dir, sunI, rPlanet, rAtmosphere, rsc, msc, rsh, msh, distr_factor);


	//  col = saturate(pow(col, 2.2));

	return float4(col, 1);
}
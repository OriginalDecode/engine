SamplerState linear_Wrap 	: register ( s0 );
Texture2D AlbedoTexture  	: register ( t0 );
Texture2D NormalTexture  	: register ( t1 );
Texture2D RoughnessTexture 	: register ( t2 );
Texture2D MetalnessTexture 	: register ( t3 );
Texture2D EmissiveTexture	: register ( t4 );
Texture2D OpacityTexture	: register ( t5 );
Texture2D AOTexture			: register ( t6 );
Texture2D HeightTexture		: register ( t7 );
Texture2D Displacement		: register ( t8 );
Texture2D LightmapTexture	: register ( t9 );
Texture2D ShininessTexture	: register ( t10 );

struct GBuffer
{
	float4 Albedo;
	float4 Normal;
	float4 Depth;
	float4 Emissive;
};

struct VS_OUTPUT
{
	float4 pos : SV_POSITION;
	float4 normal : NORMAL;
	float2 uv : TEXCOORD;
	float4 binorm : BINORMAL;
	float4 tang : TANGENT;
	float4 worldpos : POSITION;
	float2 data0 : DATA;
};

struct ps_input_no_instance
{
	float4 pos : SV_POSITION;
	float4 normal : NORMAL;
	float2 uv : TEXCOORD;
	float4 binorm : BINORMAL;
	float4 tang : TANGENT;
	float4 worldpos : POSITION;
};

GBuffer main_non_instanced(ps_input_no_instance input) : SV_Target
{
	float3 _normal = NormalTexture.Sample(linear_Wrap, input.uv).rgb * 2 - 1;
	float3 nnormal = normalize(input.normal.xyz );

	float3 binorm = normalize(cross(input.normal, input.tang));
	float3 tang = normalize(cross(input.normal, binorm));
	float3x3 tangentSpaceMatrix = float3x3(tang, binorm, nnormal);
	_normal = normalize(mul(_normal.xyz, tangentSpaceMatrix));

	_normal += 1;
	_normal *= 0.5;

	GBuffer output;

    output.Albedo = AlbedoTexture.Sample(linear_Wrap, input.uv);//float4(t,1);
    output.Normal = float4(_normal, 1); //float4(_normal, 1);// input.data0.x);
    output.Depth.x = input.pos.z;
	output.Depth.y = 0;
    
    return output;
};

GBuffer main(VS_OUTPUT input) : SV_Target
{
	float3 _normal = NormalTexture.Sample(linear_Wrap, input.uv).rgb * 2 - 1;
	float3 nnormal = normalize(input.normal.xyz );

	float3 binorm = normalize(cross(input.normal, input.tang));
	float3 tang = normalize(cross(input.normal, binorm));
	float3x3 tangentSpaceMatrix = float3x3(tang, binorm, nnormal);
	_normal = normalize(mul(_normal.xyz, tangentSpaceMatrix));

	//_normal += 1;
	//_normal *= 0.5;

	GBuffer output;

	float metalness_override = MetalnessTexture.Sample(linear_Wrap, input.uv);
	float roughness_override = RoughnessTexture.Sample(linear_Wrap, input.uv); 

    output.Albedo = AlbedoTexture.Sample(linear_Wrap, input.uv);//float4(t,1);
    output.Normal = float4(_normal, 1); //float4(_normal, 1);// input.data0.x);
    output.Depth.x = input.pos.z;
	output.Depth.y = input.data0.y;
    
    return output;


/*	float4 opacity = OpacityTexture.Sample(linear_Wrap, input.uv);

	float3 _normal = NormalTexture.Sample(linear_Wrap, input.uv).rgb * 2 - 1;
	float3 nnormal = normalize(input.normal.xyz);

	float3 binorm = normalize(cross(input.normal, input.tang));
	float3 tang = normalize(cross(input.normal, binorm));
	float3x3 tangentSpaceMatrix = float3x3(input.tang, binorm, nnormal);
	_normal = normalize(mul(_normal.xyz, tangentSpaceMatrix));

	_normal += 1;
	_normal *= 0.5;

	output = (GBuffer)0;
	float4 albedo = AlbedoTexture.Sample(linear_Wrap, input.uv);


	output.Albedo = albedo;
	output.Albedo = pow(output.Albedo,  2.2);
	
	float4 metal = MetalnessTexture.Sample(linear_Wrap, input.uv);
	float metalness = metal.r ;

	output.Normal =  float4(_normal.rgb, metalness);
	output.Depth.x = input.pos.z;
	output.Depth.y = RoughnessTexture.Sample(linear_Wrap, input.uv).r;
	output.Depth.w = 1;
	
	output.Emissive = float4(1,1,1,1);
	return output;*/
};

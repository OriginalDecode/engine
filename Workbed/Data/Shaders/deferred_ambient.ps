

cbuffer per_frame : register (b0)
{
	row_major float4x4 InvertedProjection;
	row_major float4x4 View;
	float4 CameraPosition;
};

cbuffer Ambient : register(b1)
{
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
};

SamplerState sampler0 : register (s0);
SamplerState sampler1 : register (s1);

Texture2D AlbedoTexture 	: register (t0);
Texture2D NormalTexture  	: register (t1);
Texture2D DepthTexture	 	: register (t7);
Texture2D ShadowTexture		: register (t8);
TextureCube CubeMap		 	: register (t9);
Texture2D SSAOTexture		: register (t10);

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

static const float k0 = 0.00098,
				k1 = 0.9921; 
static const float specMax = (2 / (0.0014 * 0.0014)) - 2;
static const float g_MaxT = exp2(-10 / sqrt(specMax) - k0) / k1;
static const float PI = 3.14159265;

// GGX Specular
// Source: http://www.filmicworlds.com/images/ggx-opt/optimized-ggx.hlsl

half RoughToSPow(half fRoughness)
{
	return (2.h / (fRoughness * fRoughness)) - 2.h;
}

half GetSpecPowToMip(float fSpecPow, int nMips)
{
	float fSmulMaxT = (exp2(-10 / sqrt(fSpecPow)) - k0) / k1;
	return float(nMips - 1) * (1 - clamp(fSmulMaxT / g_MaxT, 0.0, 1.0));
}

half3 ReflectionFresnel(const half3 substance, const half3 light_dir, const half3 half_vec, half roughness)
{
	half LdotH = saturate(dot(light_dir, half_vec));
	LdotH = 1.0f - LdotH;
	LdotH = pow(LdotH, 5); //max(0, min(pow(LdotH, 5), 1));
	half3 fresnel = LdotH * (1.f - substance);
	fresnel = fresnel / (2 - 1 * roughness);
	fresnel = substance + fresnel;
	return fresnel;
}

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, View);
    return world_pos;
}
// http://orsvarn.com/post/pbr-shader-source/
// Source: https://github.com/godotengine/godot/blob/df573f5c3a76155842e43ea0dbab594e3944b114/drivers/gles3/shaders/scene.glsl
float4 main(VS_OUTPUT input) : SV_Target
{
	float4 depth = DepthTexture.Sample(sampler0, input.uv);

	if(depth.x <= 0)
		discard;

	int nMips = 0;
	int width = 0;
	int height = 0;
	CubeMap.GetDimensions(0, width, height, nMips);


	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);

	half roughness = depth.y;
	
	half roughnessOffsetted = pow(roughness, 8192);
	half lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips);

	float metalness = normal.w;

	normal *= 2;
	normal -= 1;


    float4 pixel_pos = getWorldPos(input.uv, depth.x);

	float4 to_eye = normalize(CameraPosition - pixel_pos);
	float3 refVec = normalize(reflect(to_eye.xyz, normal.xyz));

	float4 reflection_fresnel = float4(ReflectionFresnel(albedo.rgb, normal.xyz, to_eye, roughnessOffsetted), 1);
	float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);


	float4 cube = CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * reflection_fresnel;
	float4 cube_ambient = CubeMap.SampleLevel(sampler1, normal, lysMipMap) * metalness_albedo * (1 - reflection_fresnel);
	albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);

	float4 diffuse = 0; // metalness_albedo * cube_ambient;
	float4 spec = 0;

	float3 light_dir = light_direction.xyz;
	float3 light_col = float3(1, 0, 0);
	float light_intensity = 100;
	float rough2 = roughness * roughness;
	float rough2half = rough2 / 2;
	float NdC = saturate(dot(normal, to_eye)); //should this really be saturated?
	float3 half_vec = (to_eye + light_dir) / length(to_eye + light_dir);

	//float NdL = dot(light_dir, normal);

	float4 newPos = pixel_pos + (normal * 0.4);
	newPos.w = 1;
	float4 shadowVec = mul(newPos, ShadowMVP);
	shadowVec.xyz /= shadowVec.w;
	shadowVec.y = -shadowVec.y;
	shadowVec.x = shadowVec.x;
	shadowVec.xy += 1;
	shadowVec.xy *= 0.5;

	float compareValue = shadowVec.z;
	float sampleValue = ShadowTexture.Sample(sampler0, shadowVec.xy).r;

	bool in_view = (shadowVec.x < 0 || shadowVec.x > 1 || shadowVec.y > 1 || shadowVec.y < 0);
	in_view = !in_view;
	const bool in_shadow = (sampleValue < compareValue); 
	//if(in_view && !in_shadow)
	{
		for(int i = 0; i < 1; i++)
		{
			// diffuse
			float SatNdL = dot(-light_dir, normal);
			diffuse += float4( ( SatNdL * 1 / PI)  * light_col * albedo.rgb, 1.0f);
			//spec
			float HdN = saturate(dot(half_vec, normal));
			float NdL = saturate(dot(normal, light_dir));
			float EdH = saturate(dot(-to_eye, half_vec));
			float LdH = saturate(dot(light_dir, half_vec));
			LdH = 1 - LdH;
			LdH = pow(LdH, 5);
			half4 schlickFresnel = LdH * ( 1 - metalness_albedo);
			schlickFresnel = schlickFresnel / (6 - (5 * roughness));
			schlickFresnel = metalness_albedo + schlickFresnel;
			float m = rough2;
			float m2 = m*m;
			float denominator = HdN * HdN * (m2 - 1) + 1;
			float ggxDistr = m2 / (PI * denominator * denominator);
			float SchlickGGXGeo = (NdC / (NdC * (1 - rough2half ) + rough2half));
			float k = rough2half;
			float G1V = NdC * ( 1.f - k ) + k;
			float G1L = NdL * ( 1.f - k ) + k;
			float V = 0.25f / (G1V * G1L);
			spec += saturate(((schlickFresnel * ggxDistr * V) * float4(light_col, 1)) * light_intensity) * NdL;
		}
	}
	diffuse += cube_ambient * albedo;
	
	// float4 schlickFres = (metalness_albedo + ( 1 - metalness_albedo) * pow(1 - NdC, 5));
		
	float LdH = saturate(dot(light_dir, half_vec));
	half4 schlickFresnel = LdH * ( 1 - metalness_albedo);
	schlickFresnel = schlickFresnel / (6 - (5 * roughness));
	schlickFresnel = metalness_albedo + schlickFresnel;

	float4 output = 0;
	output = lerp(diffuse, cube, schlickFresnel);
	output += spec;
//output = (output);

	return saturate(output);
};

cbuffer Ambient : register(b0)
{
	float4 camera_position;
	row_major float4x4 InvertedProjection;
	row_major float4x4 InvertedView;
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
};

Texture2D ShadowTexture		: register ( t8 );
TextureCube CubeMap		 	: register ( t9 );
Texture2D SSAOTexture		: register ( t10 );

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

#include "PBL_Functions.hlsl"

float4 main(VS_OUTPUT input) : SV_Target
{
	/*float4 depth = DepthTexture.Sample(sampler0, input.uv);

	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);
	float metal_fix = normal.w;


	float4 metalness = float4(metal_fix, metal_fix, metal_fix, metal_fix);
	normal *= 2;
	normal -= 1;

	float roughness = depth.y;
	float roughnessOffsetted = pow(8192, roughness);

	float4 substance = (0.04f - 0.04f * metalness) + albedo * metalness;
	float4 metalnessAlbedo = albedo - (albedo * metalness);

	float x = input.uv.x * 2.f - 1.f;
	float y = (1.f - input.uv.y) * 2.f - 1.f;
	float z = depth.x; 

	float4 worldPosition = float4(x, y, z, 1.f);
	worldPosition = mul (worldPosition, InvertedProjection);
	worldPosition = worldPosition / worldPosition.w;
	worldPosition = mul(worldPosition, InvertedView);	*/

	

	DeferredPixelData pData = CalculateDeferredPixelData(input.uv);
	LightVectors lData = CalculateLightVectorsDirectional(pData, camera_position, light_direction);
	float4 ssao = 1;//SSAOTexture.Sample(point_Clamp, input.uv);
	
	float4 worldPosition = pData.world_pos;

	float ao =  ssao.x;
	float3 toEye = normalize(camera_position.xyz - worldPosition.xyz);
	float3 reflection_fresnel = ReflectionFresnel(pData.substance, pData.normal, toEye, 1 - pData.roughness);
	float3 reflectionVector = reflect(toEye, pData.normal.xyz);

	float3	ambientDiffuse = CubeMap.SampleLevel(sampler0, reflectionVector, 9).rgb * 
							(pData.metalness) + pData.metalnessAlbedo * (1 - reflection_fresnel) * ao;
  
	float fakeLysSpecularPower = RoughToSPow(pData.roughness);
	float lysMipMap = GetSpecPowToMip(fakeLysSpecularPower, 12);
    
	float3 ambientSpec = CubeMap.SampleLevel(sampler0, reflectionVector,lysMipMap).xyz * ao * reflection_fresnel;
	float3 final_color = saturate(ambientDiffuse + ambientSpec);
	//float NdotL = dot(pData.normal.xyz, light_direction);
	
	/* Shadow */
	
	float4 newPos = worldPosition + (pData.normal * 0.4);
	newPos.w = 1;
	float4 shadowVec = mul(newPos, ShadowMVP);
	shadowVec.xyz /= shadowVec.w;
	shadowVec.y = -shadowVec.y;
	shadowVec.x = shadowVec.x;
	shadowVec.xy += 1;
	shadowVec.xy *= 0.5;

	float3 F = saturate(Fresnel(pData.substance, -lData.light_dir, lData.halfVec));
	float D = saturate(D_GGX(lData.HdotN,(pData.roughness) / 2.f));
	float V = saturate(V_SchlickForGGX((pData.roughness) / 2.f, lData.NdotV, lData.NdotL));

	final_color *= (F * D * V) * light_color;



	float compareValue = shadowVec.z;
	float sampleValue = ShadowTexture.Sample(sampler0, shadowVec.xy).x;
	if(sampleValue < compareValue)
 		final_color = 0.0f;

 	/* Shadow end */

	float3 output = saturate(final_color);
	// return float4(final_color, 1);
	return float4(output + (ambientDiffuse * 0.42f), 1.f);
};

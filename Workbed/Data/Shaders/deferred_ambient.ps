

cbuffer per_frame : register (b0)
{
	row_major float4x4 InvertedProjection;
	row_major float4x4 View;
};

cbuffer Ambient : register(b1)
{
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
};

SamplerState sampler0 : register (s0);
SamplerState sampler1 : register (s1);

Texture2D AlbedoTexture 	: register (t0);
Texture2D NormalTexture  	: register (t1);
Texture2D Emissive  	: register (t4);
Texture2D DepthTexture	 	: register (t7);
Texture2D ShadowTexture		: register (t8);
TextureCube CubeMap		 	: register (t9);
Texture2D SSAOTexture		: register (t10);
TextureCube CubeMap2		 	: register (t11);


struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

static const float k0 = 0.00098,
				k1 = 0.9921; 
static const float specMax = (2 / (0.0014 * 0.0014)) - 2;
static const float g_MaxT = exp2(-10 / sqrt(specMax) - k0) / k1;
static const float PI = 3.14159265;

// GGX Specular
// Source: http://www.filmicworlds.com/images/ggx-opt/optimized-ggx.hlsl

float RoughToSPow(float fRoughness)
{
	return (2.h / (fRoughness * fRoughness)) - 2.h;
}

float GetSpecPowToMip(float fSpecPow, int nMips)
{
	float fSmulMaxT = (exp2(-10 / sqrt(fSpecPow)) - k0) / k1;
	return float(nMips - 1) * (1 - clamp(fSmulMaxT / g_MaxT, 0.0, 1.0));
}

float3 ReflectionFresnel(const float3 substance, const float3 light_dir, const float3 half_vec, float roughness)
{
	float LdotH = saturate(dot(light_dir, half_vec));
	LdotH = 1.0f - LdotH;
	LdotH = pow(LdotH, 5); //max(0, min(pow(LdotH, 5), 1));
	float3 fresnel = LdotH * (1.f - substance);
	fresnel = fresnel / (2 - 1 * roughness);
	fresnel = substance + fresnel;
	return fresnel;
}

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, View);
    return world_pos;
}
// http://orsvarn.com/post/pbr-shader-source/
// Source: https://github.com/godotengine/godot/blob/df573f5c3a76155842e43ea0dbab594e3944b114/drivers/gles3/shaders/scene.glsl
float4 main(VS_OUTPUT input) : SV_Target
{
	float4 camera_position = View._m30_m31_m32_m33;
	float4 depth = DepthTexture.Sample(sampler0, input.uv);

	if(depth.x <= 0)
		discard;

	int nMips[2];
	int width[2];
	int height[2];
	CubeMap.GetDimensions(0, width[0], height[0], nMips[0]);
	CubeMap2.GetDimensions(0, width[1], height[1], nMips[1]);


	float3 light_dir = (light_direction.xyz + 0.0001);

	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);
	float4 base_col = albedo;
	float roughness = 1 - albedo.a;
	
	float roughnessOffsetted = pow(roughness, 8192);
	float lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips[0]);
	float specPow = GetSpecPowToMip(RoughToSPow(roughness), nMips[1]);

	float metalness = normal.w;

	normal *= 2;
	normal -= 1;


    float4 pixel_pos = getWorldPos(input.uv, 1 - depth.x);

	float4 to_eye = normalize(camera_position - pixel_pos);
	float3 refVec = reflect(to_eye.xyz, normal.xyz);

	float3 ref = ReflectionFresnel(albedo.rgb, normal.xyz, to_eye, roughnessOffsetted);

	float4 reflection_fresnel = float4(ref, 1);
	float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);


	float4 cube = CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * reflection_fresnel; //makes terrain look strange
	float4 cube_ambient = CubeMap.SampleLevel(sampler1, normal, lysMipMap) * metalness_albedo * reflection_fresnel;

	float4 cube2 = CubeMap2.SampleLevel(sampler1, -refVec, specPow) * reflection_fresnel; //makes terrain look strange
	float4 cube_ambient2 = CubeMap2.SampleLevel(sampler1, normal, specPow) * metalness_albedo * reflection_fresnel;

	float4 active_cube[2];
	active_cube[0] = cube_ambient2;
	active_cube[1]= cube2;


	// return metalness_albedo;
	albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);

	float4 diffuse = 0; // metalness_albedo * cube_ambient2;
	float4 spec = 0;
	float3 light_col = float3(1, 1, 1);
	float3 light_col2 = float3(1, 1, 1);
	float light_intensity = 1;
	float rough2 = roughness * roughness;
	float rough2half = rough2 / 2;
	float3 half_vec = normalize(light_dir + to_eye);
	float NdL = saturate(dot(normal, light_dir));

	//return base_col * dot(normal.rgb, light_dir);

	float NdC = dot(normal, to_eye); 

	for(int i = 0; i < 0; i++)
	{
		// diffuse
		diffuse += float4( ( NdL * (1 / PI))  * light_col * albedo.rgb, 1.0f);		
		//spec
		float HdN = saturate(dot(half_vec, normal));
		float LdH = saturate(dot(light_dir, half_vec));
		LdH = 1 - LdH;
		LdH = pow(LdH, 5);
		float4 schlickFresnel = LdH * ( 1 - metalness_albedo);
		schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
		schlickFresnel = metalness_albedo + schlickFresnel;
		float m = rough2;
		float m2 = m*m;
		float denominator = HdN * HdN * (m2 - 1) + 1;
		float ggxDistr = m2 / (PI * denominator * denominator);
		float SchlickGGXGeo = (NdC / (NdC * (1 - rough2half ) + rough2half));
		float k = rough2half;
		float G1V = NdC * ( 1.f - k ) + k;
		float G1L = NdL * ( 1.f - k ) + k;
		float V = 0.25f / (G1V * G1L);

		spec += saturate(((schlickFresnel * ggxDistr * V) * float4(light_col, 1)) * light_intensity) * NdL;
	}
	
	diffuse += active_cube[0] * albedo;

	float LdH = saturate(dot(-light_dir, half_vec));
	float4 schlickFresnel = LdH * ( 1 - metalness_albedo);
	schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
	schlickFresnel = metalness_albedo + schlickFresnel;

	float4 output = 0;
	output = lerp(diffuse, active_cube[1], schlickFresnel);
	output += spec;
	return saturate(output);

	
};




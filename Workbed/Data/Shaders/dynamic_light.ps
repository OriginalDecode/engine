#include "PBL_Functions.hlsl"
cbuffer per_frame : register(b0)
{
	row_major float4x4 InvertedProjection; 
	row_major float4x4 InvertedView; 
};

cbuffer per_object : register(b1)
{
	float4 color;
	float4 position;
	float4 cam_pos;
	row_major float4x4 shadowMVP;
#ifdef SPOTLIGHT
    float4 direction;
	float angle;
	float range;
	float2 x;
#endif
};


struct psInput
{
	float4 pos	: SV_POSITION;
#ifdef SPOTLIGHT
	float4 normal : NORMAL;
#endif
	float4 uv	: POSITION;
	float range : RANGE;
#ifdef SPOTLIGHT
	float cosAngle : COSANGLE;
    float angle : ANGLE;
	float intensity : INTENSITY;
	float4 world : WORLD;
#endif
};

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.0f - 1.0f;
	float y = (1.0f - tex_coord.y) * 2.0f - 1.0f;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.0f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, InvertedView);
    return world_pos;
}

float DegreeToRad(float aDegree)
{
	return aDegree * (3.1415926535 / 180.0);
}

float4 main(psInput input) : SV_Target
{
   	input.uv /= input.uv.w;
	float2 texCoord = input.uv.xy;

    float4 albedo = AlbedoTexture.Sample(sampler0, texCoord);
	float4 normal = NormalTexture.Sample(sampler0, texCoord);
	float4 depth = DepthTexture.Sample(sampler0, texCoord);
	float metalness = normal.w;
	float roughness = 1 - albedo.a;
	
	normal *= 2;
	normal -= 1;
	
	float4 world_pos = getWorldPos(texCoord, 1 - depth.r);

    float4 final_color = 1;

	float3 _pos = position.xyz;
	float3 _worldpos = world_pos.xyz;

	float3 lightToPixel = _worldpos - _pos;
	float3 toLight = _pos - _worldpos;
	float ln = length(toLight);
	float3 light_dir = toLight / ln; //normalize(toLight);

    float NdL = normalize(dot(light_dir, normal.xyz));

	float3 to_eye = normalize(cam_pos.xyz - _worldpos);	
	float3 halfVec = normalize(light_dir + to_eye);

	float HdN = normalize(dot(halfVec, normal));
	float NdV = normalize(dot(normal, to_eye));

	int nMips = 0;
	int width = 0;
	int height = 0;
	CubeMap.GetDimensions(0, width, height, nMips);

	float roughnessOffsetted = pow(roughness, 8192);
	float lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips);
	float3 refVec = reflect(to_eye.xyz, normal.xyz);
	float4 reflection_fresnel = float4(ReflectionFresnel(albedo.rgb, normal.xyz, to_eye, roughnessOffsetted), 1);
	float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);

	float4 cube = 0; //CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * reflection_fresnel;
	float4 cube_ambient = 0; //CubeMap.SampleLevel(sampler1, normal, lysMipMap) * metalness_albedo *  reflection_fresnel;
	float4 diffuse = 0;
	//albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);

	diffuse += float4( ( NdL * 1 / PI) * color * albedo.rgb, 1.0f);

	float LdH = saturate(dot(light_dir, halfVec));
	LdH = 1 - LdH;
	LdH = pow(LdH, 5);
	float4 schlickFresnel = LdH * ( 1 - metalness_albedo);
	schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
	schlickFresnel = metalness_albedo + schlickFresnel;

	
	float Distr = D_GGX(HdN, roughness);
	float V = V_SchlickForGGX(roughness, NdV, NdL);
	float4 spec = 0;

	float attenuation = 0;
	float intensity = 1;
#ifdef SPOTLIGHT

    float cosCone = cos(angle);
	float3 lightVec = normalize(toLight);
	float spotfactor = dot(normalize(lightToPixel), direction); //rho
	//angle light_angle

	if(spotfactor < cosCone)
		discard;

	float rho = acos(spotfactor);
	float dif = 3.14 / 2 - acos(angle);
	float angularAttenuation = ( 1.0 - ( 1.0 - spotfactor) *  1 / ( 1 - cosCone)) ;
	angularAttenuation= clamp((angle - rho) / dif, 0.0, 1.0);
	float linearAttenuation = CalculateTotalAttenuation(ln, input.range) ;
	attenuation = linearAttenuation * angularAttenuation ;



	intensity = 1;
	spec += saturate((((schlickFresnel * Distr * V) ) * color) );
#endif

#ifdef POINTLIGHT
	float pRadius = input.range;
	float3 pL = _pos - _worldpos;
	float pDist = length(pL);
	float pD = max(pDist - pRadius, 0);

	float pDenom = ln / pRadius + 0.001 ;
	float pAtten = 1 / (pDenom * pDenom);

	pAtten = (pAtten - 0.0001) / ( 1 - 0.0001);
	pAtten = max(pAtten, 0 );

	attenuation = 0.9f - pDenom ; //CalculateTotalAttenuation(ln, input.range / 2);

	spec += (((schlickFresnel * Distr * V) )  ) ;
	intensity ;
	
#endif
	
	diffuse += cube_ambient * albedo;
	float4 output = 0;
	output = lerp(diffuse, cube, schlickFresnel);
	output += spec;

	
	return saturate((output * attenuation)) * NdL * intensity;

};


cbuffer per_frame : register (b0)
{
	row_major float4x4 InvertedProjection;
	row_major float4x4 View;
};

cbuffer Ambient : register(b1)
{
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
	float4 viewDir;
};

SamplerState sampler0 : register (s0);
SamplerState sampler1 : register (s1);

Texture2D AlbedoTexture 	: register (t0);
Texture2D NormalTexture  	: register (t1);
Texture2D Emissive  	: register (t4);
Texture2D DepthTexture	 	: register (t7);
Texture2D ShadowTexture		: register (t8);
TextureCube CubeMap		 	: register (t9);
Texture2D SSAOTexture		: register (t10);
TextureCube CubeMap2		 	: register (t11);


struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

static const float k0 = 0.00098,
				k1 = 0.9921; 
static const float specMax = (2 / (0.0014 * 0.0014)) - 2;
static const float g_MaxT = exp2(-10 / sqrt(specMax) - k0) / k1;
static const float PI = 3.14159265;

// GGX Specular
// Source: http://www.filmicworlds.com/images/ggx-opt/optimized-ggx.hlsl

float RoughToSPow(float fRoughness)
{
	return (2.h / (fRoughness * fRoughness)) - 2.h;
}

float GetSpecPowToMip(float fSpecPow, int nMips)
{
	float fSmulMaxT = (exp2(-10 / sqrt(fSpecPow)) - k0) / k1;
	return float(nMips - 1) * (1 - clamp(fSmulMaxT / g_MaxT, 0.0, 1.0));
}

float3 ReflectionFresnel(const float3 substance, const float3 light_dir, const float3 half_vec, float roughness)
{
	float LdotH = saturate(dot(light_dir, half_vec));
	LdotH = 1.0f - LdotH;
	LdotH = pow(LdotH, 5); //max(0, min(pow(LdotH, 5), 1));
	float3 fresnel = LdotH * (1.f - substance);
	fresnel = fresnel / (2 - 1 * roughness);
	fresnel = substance + fresnel;
	return fresnel;
}

float4 getWorldPos(float2 tex_coord, float depth)
{
    float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = world_pos / world_pos.w;
	world_pos = mul(world_pos, View);
    return world_pos;
}
// http://orsvarn.com/post/pbr-shader-source/
// Source: https://github.com/godotengine/godot/blob/df573f5c3a76155842e43ea0dbab594e3944b114/drivers/gles3/shaders/scene.glsl

float3 OrenNayarBRDF(float3 normal, 
float3 view_dir, 
float3 world_pos, 
float3 light_dir, 
float roughness,
float3 albedo)
{
	float NdL = dot ( normal, light_dir );
	float NdV = dot ( normal, view_dir );
	float LdV = dot ( light_dir, view_dir );

	float s = LdV - NdL * NdV;
	float t = lerp(1.0, max(NdL, NdV), step(0.0, s));

	float r2 = roughness * roughness;

	float3 A = 1.0 + r2 * (- 0.5 / (r2 + 0.33) + 0.17 * albedo / (r2 + 0.13) ); //(albedo / ( r2 / (r2 + 0.13) + 0.5 / (r2 + 0.33 ) ) );
	float3 B = 0.45 * r2 / (r2 + 0.09);

	albedo = albedo * max(0.0, NdL) * (A + B * s / t) / 3.14;

	return albedo;
}

float3 CookTorranceBRDF(float D, float3 F, float G, float ndl, float ndv)
{
	float3 f = D * F * G;
	f = f / ( 4  * ndl * ndv);
	return f;
}

//Schlick-GGX, Geometric Shadowing (G) , Smith schlick-GGX.
float Geometric_Smith_Schlick_GGX(float r, float ndv, float ndl)
{

	float k = (r * r) * 0.5f;
	float GV = ndv / (ndv * (1 - k) + k);
	float GL = ndl / (ndl * (1 - k) + k);

	return GV*GL;
}

// GGX (Trowbridge-Reitz) (D) Normal Distribution Function , NDF
float D_GGX(float HdN, float r) 
{
	float m = r*r;
	float m2 = m*m;
	float Denominator = HdN*HdN*(m2 - 1.f) + 1.f;
	float D = m2 / (3.14159*Denominator*Denominator);
	return D;
}

//f0 = reflectance at normal incidence (F)
float3 Fresnel(float3 view_dir, float3 half_vec, float3 f0)
{
	float VdH = dot(view_dir, half_vec);
	VdH = 1 - VdH;
	VdH = pow(VdH, 5);

	float3 F =  f0 + ( 1 - f0);
	F *= VdH;	
	return F;

	// LdH = pow(LdH, 5);
	// float3 schlickFresnel = 0; //LdH * ( 1 - metalness_albedo);
	//schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
	//schlickFresnel = metalness_albedo + schlickFresnel;
}

float4 main(VS_OUTPUT input) : SV_Target
{
	float4 camera_position = View._m30_m31_m32_m33;
	float4 depth = DepthTexture.Sample(sampler0, input.uv);


	int nMips[2];
	int width[2];
	int height[2];
	CubeMap.GetDimensions(0, width[0], height[0], nMips[0]);
	CubeMap2.GetDimensions(0, width[1], height[1], nMips[1]);


	float3 light_dir = -light_direction.xyz;

	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	return float4(albedo.rgb, 1);
	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);
	float4 base_col = float4(albedo.rgb, 1);
	float roughness = 1 - albedo.a;
	
	float roughnessOffsetted = pow(roughness, 8192);
	float lysMipMap = GetSpecPowToMip(RoughToSPow(roughness), nMips[0]);
	float specPow = GetSpecPowToMip(RoughToSPow(roughness), nMips[1]);

	float metalness = normal.w;

	normal *= 2;
	normal -= 1;


    float4 pixel_pos = getWorldPos(input.uv, 1 - depth.x);
	float4 to_eye = normalize(camera_position - pixel_pos);

	float3 refVec = reflect(to_eye.xyz, normal.xyz);

	float3 ref = ReflectionFresnel(albedo.rgb, normal.xyz, to_eye, roughnessOffsetted);

	float4 reflection_fresnel = float4(ref, 1);
	//float4 metalness_albedo = float4((0.04f - 0.04f * metalness) + albedo.rgb * metalness, 1.0);
	float4 metalness_albedo = float4(lerp(0.04f.rrr, albedo.rgb, metalness), 1);
	float4 cube = CubeMap.SampleLevel(sampler1, refVec, lysMipMap) * ( reflection_fresnel ); //makes terrain look strange
	float4 cube_ambient = CubeMap.SampleLevel(sampler1, normal, lysMipMap) * metalness_albedo * (  reflection_fresnel);

	// return metalness_albedo;

	float4 diffuse = 0;// metalness_albedo * cube_ambient2;
	float4 spec = 0;
	float3 light_col = float3(1, 1, 1);
	float3 light_col2 = float3(1, 1, 1);
	float light_intensity = 1;
	float rough2 = roughness * roughness;
	float rough2half = rough2 / 2;
	float3 half_vec = normalize(light_dir + viewDir); // / length(light_dir + viewDir);
    float NdL = max(0,dot(normal.xyz, -light_dir));

	float3 radiance = CubeMap.SampleLevel(sampler1, normal, lysMipMap).rgb * (1 - reflection_fresnel);
	//return base_col * dot(normal.rgb, light_dir);
	float3 oren = OrenNayarBRDF(normal.xyz, viewDir, float3(0,0,0), light_dir, roughness, albedo.rgb);

	float HdotN = dot(half_vec, normal);
	float NdV = dot(normal, viewDir); 
	
	float D = D_GGX(HdotN, roughness);
	float3 F = Fresnel(light_dir, half_vec, radiance.rgb);
	float G = Geometric_Smith_Schlick_GGX(roughness, NdV, NdL);
	float3 cook = CookTorranceBRDF(D,F,G, NdL, NdV);
	
	float3 dif = albedo.rgb / 3.14;

	float3 cFinal = float3(1,1,1) * NdL * ( dif * ( 1 - cook) + cook);
	return float4(cFinal, 1);

	return float4(cook, 1);
	
	return float4(oren, 1);
	
	float LdH = saturate(dot(light_dir, half_vec));
	LdH = 1 - LdH;
	LdH = pow(LdH, 5);
	float4 schlickFresnel = LdH * ( 1 - metalness_albedo);
	schlickFresnel = schlickFresnel / (6 - (5 * roughnessOffsetted));
	schlickFresnel = metalness_albedo + schlickFresnel;
	//F


	for(int i = 0; i < 0; i++)
	{
		// diffuse
		//diffuse += float4( ( NdL * (1 / PI))  *  albedo.rgb, 1.0f);		
		//spec
		float HdN = saturate(dot(half_vec, normal));
		
		float m = rough2;
		float m2 = m*m;
		float denominator = HdN * HdN * (m2 - 1) + 1;
		
		float ggxDistr = m2 / (PI * denominator * denominator); //D
		
		float SchlickGGXGeo = (NdV / (NdV * (1 - rough2half ) + rough2half)); //G
		
		float k = rough2half;
		float G1V = NdV * ( 1.f - k ) + k;
		float G1L = NdL * ( 1.f - k ) + k;
		float V = 0.25f / (G1V * G1L);

		spec += schlickFresnel;
		spec *= ggxDistr;
		spec *= V;
		spec *= NdL;
		spec *= float4(light_col, 1);
		spec *= light_intensity;

		//spec += saturate(((schlickFresnel * ggxDistr * V) * float4(light_col, 1)) * light_intensity) * NdL;
	}
	
//	diffuse += active_cube[0] * albedo;

	float4 output = 0;
	output = diffuse; //lerp(diffuse, cube, schlickFresnel);
	output += spec;
	return saturate(output);

	
};




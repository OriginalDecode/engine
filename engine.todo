Engine Tasks:
  Note:
    The refs in Visual studio is just a fast link to the *.lib output file, we could probably set this up better in someway.
    Add all the .libs to the .exe might work

  Input Handling: 
    ☐ Create an input system that supports rebindable keys from the user 
     Maybe should listen to input using the observer pattern.
     This action is bound to this function, this function is bound to this key, key comes from the outside
  Level / World:
    ☐ Rework the loading to handle patches instead of loading the entire world in 1 go. @low
    ☐ Load patches with entities @low 
    ☐ Load patches around the player position @low
    ☐ Distance LOD from player @low
    ☐ Distance Fog or other fancy solution @low
    ✔ Quadtree / Octree @done (17-01-29 23:57)
       The world needs a basic implementation of a Quadtree or an Octree
    ✔ Treenode updates entities by themselves. @done (17-01-29 23:57)
    ✔ Remove / Add Nodes dynamically @started @done (17-02-07 14:26)
    ☐ Move entities from node to node with minimum overhead. @started 
      ✔ BUG: Update time of the octree increases overtime the more you call the "InsertDweller" function @critical @done (17-02-07 14:26)
  Entities:
    ☐ Create and edit entities in engine. @low
    ☐ Standardize rotations in engine @high
     Shadow Spotlights, Lights, Camera etc..
    ☐ Flag lights that should be able to cast shadows. @low
    ✔ OBB click collision on entities @done (17-01-22 00:59)
      ✔ Add box around entity @done (17-01-18 21:05)
      ✘ Use physics for OBB click collision on entities @cancelled (17-01-18 18:43)
      ✔ Receive callback on clicked entity @done (17-01-18 21:05)
      ✔ Have the box be oriented around the model / entity @done (17-01-18 22:28)
        Should preferrably rotate with the entity as well.
        I can do a screen-space clickable area to collide with the object
        and then when the entity has been interacted with
      ✔ Collision Checks are a bit broken on some rotations @done (17-01-22 00:59)
        ✔ Fix it @done (17-01-22 00:59)
    ☐ Entity rotation & physics rotation should be loaded in euler angles
    ☐ When entities save, their rotation is stored as euler angles
    ☐ When entities are edited in the engine, they will change with quaternions 
  Debug UI:
    ✔ Hook up some kind of debug/edit-mode UI (imgui) @done (17-01-19 22:32)
    ✔ Configure imgui @done (17-01-22 00:59)
    ✔ Hook up some relevant variables @done (17-01-22 00:59)
    ☐ Entity Editing @low
  Particles:
    ☐ Custom particle shapes 
    ☐ Emitter System
  Network:
    ☐ Add the network API to the engine and make the engine able to run without Graphics.
    ☐ NetworkComponent for Entities should be setting positions of the other entities.
    ☐ The level / world needs/Should be verified by the server with some kind of hash 
       (network_version + map_name + user_name) or something like that
    ☐ FlatBuffers
      Calle recomended this, you can access the data without deserializing / unpacking messages
    ☐ Make the Engine run in the Terminal without any graphics or rendercommands. @low
      This is to make sure that I can run the game on Linux.
    ☐ Handshake message
      ☐ Check MTU size of Client
    ☐ Reliability filter
  Shaders:
    Compute Shaders:
       ☐ Experiment with compute shaders
         ☐ Send a buffer of work to the shader
         ☐ read the data on the CPU
         This should not be that different from what I already do in the 
  Rendering:
     ☐ Abstract
       ☐ All the calls should go through the interface and not through the API.  
       ☐ Remove GetAPI()
         GetAPI() should be replaced with something else, e.g GetRenderInterface() or GetInterface() or GetGraphicsAPI(), simply GetAPI() does not communicate that it's getting the
         graphics api from the engine, should the engine be responsible for the api or is it the renderer that should be responsible for that? Should the renderer be the one that dictates
         everything? All the setting of states? Would make sense.

     ☐ Resize Message 
        Make it work, everything looks funky and does not work correctly when you have a requested size of 1920x1080 but it ends up as 1910x1057 or something
     ☐ Finish the current render frame before initiating / removing a main/sub state.
     ☐ Add Vulkan to regular build instead of having its separate build
     ☐ Check if the compile platform is windows for DirectX
     ☐ Post Processing Effects (HDR, Blur, Bloom, ...)
     ☐ Soft Shadows
     ✘ Separate light pass to its own texture @cancelled (17-02-20 13:15)
     ☐ Move directional light to its own shader pass & not when the ambient runs.
  StateStack:
    ✔ Move to engine @done (17-01-29 23:57)
      States are still game-bound but having the statestack in the Engine should make it easier to move between projects
  Memory:
    ☐ Investigate Memory Allocators @started
    ☐ Implement custom memory allocators @high 
      ☐ Linear Allocator
      ☐ Stack Allocator
      ☐ Circle Allocator
      The main purpose for implementing custom allocators is to solve the potential memory lookup issue 
      when creating new nodes in the octree.
    ☐ Rewrite the CommonLib containers 
       They will have to use the allocators as well else they will not function.
       They will need to contain an allocator or request one at creation from somewhere
  Physics:
    ☐ Physics Bodies
      ☐ Mesh
      ☐ Cube
      ☐ Sphere
    ☐ ASync? Calculations on GPU?
  Terrain:
    Terrain patches that contains its own physics? Generate multiple levels of collision mesh for terrain to LoD it?
    ☐ Merge the render & physics body into one object

  Multi-Threading:
    ☐ Investigate fiber
    ☐ Investigate possible performance gains (not that I need them right now) from internally threading physics
    ☐ Investigate grouping up vertex buffers & index buffers
      ☐ CommandBuffers / RenderCommands
      ☐ A big drawcall instead of several small ones. Context swaps are expensive and can be solved by having a lot of vertices & indices in a single call. 
    ☐ TreeNodes to be threaded?
  I/O:
    ☐ Thread loading of models.
CommonLib:
  Math:
    ☐ Quaternion -> Matrix
        ☐ Convert quaternion rotation into matrix
        ☐ Convert matrix rotation into quaternion
  Containers:
    ☐ GrowingArray might be broke
    ☐ Rewrite with the use of custom allocators
      Use different init functions for custom allocators?
        growingarray::Initiate(size, void*, allocator&)


cbuffer Ambient : register(b0)
{
	float4 camera_position;
	row_major float4x4 InvertedProjection;
	row_major float4x4 InvertedView;
	row_major float4x4 ShadowMVP;
	float4 light_direction;
	float4 light_color;
};

SamplerState sampler0 : register ( s0 );

Texture2D AlbedoTexture 	: register ( t0 );
Texture2D NormalTexture  	: register ( t1 );
Texture2D DepthTexture	 	: register ( t7 );
Texture2D ShadowTexture		: register ( t8 );
TextureCube CubeMap		 	: register ( t9 );
Texture2D SSAOTexture		: register ( t10 );

struct VS_OUTPUT
{
	float4 pos	: SV_POSITION0;
	float2 uv	: TEXCOORD;
};

static const float PI = 3.14159265;

float3 Fresnel_Schlick(float3 specularColor, float3 h, float3 v)
{
    return (specularColor + (1.0f - specularColor) * pow((1.0f - saturate(dot(v, h))), 5));
}

float Fresnel_Schlick(float u)
{
    float m = saturate( 1.0f - u);
    float m2 = m*m;
    return m2*m2*m;
}

float sqr(float x)
{
    return x*x;
}

float GTR2_aniso(float NdH, float HdX, float HdY, float ax, float ay)
{
    return 1.0f / (PI * ax*ay * sqr(sqr(HdX/ax) + sqr(HdY/ay) + NdH*NdH));
}

float smithG_GGX(float NdV, float alphaG)
{
    float a = alphaG*alphaG;
    float b = NdV*NdV;
    return 1.0f / (NdV + sqrt(a + b - a*b));
}

float GTR1(float NdH, float a)
{
    if (a >= 1.0f)
    {
        return 1.0f / PI;
    }

    float a2 = a*a;
    float t = 1.0f + (a2 - 1.0f) * NdH * NdH;
    return (a2 - 1.0f) / (PI*log(a2)*t);
}

float NormalDistribution_GGX(float a, float NdH)
{
    // Isotropic ggx.
    float a2 = a*a;
    float NdH2 = NdH * NdH;

    float denominator = NdH2 * (a2 - 1.0f) + 1.0f;
    denominator *= denominator;
    denominator *= PI;

    return a2 / denominator;
}

float NormalDistribution_BlinnPhong(float a, float NdH)
{
    return (1 / (PI * a * a)) * pow(NdH, 2 / (a * a) - 2);
}

float NormalDistribution_Beckmann(float a, float NdH)
{
    float a2 = a * a;
    float NdH2 = NdH * NdH;

    return (1.0f/(PI * a2 * NdH2 * NdH2 + 0.001)) * exp( (NdH2 - 1.0f) / ( a2 * NdH2));
}

float Geometric_Implicit(float a, float NdV, float NdL)
{
    return NdL * NdV;
}

float Geometric_Neumann(float a, float NdV, float NdL)
{
    return (NdL * NdV) / max(NdL, NdV);
}

float Geometric_CookTorrance(float a, float NdV, float NdL, float NdH, float VdH)
{
    return min(1.0f, min((2.0f * NdH * NdV)/VdH, (2.0f * NdH * NdL)/ VdH));
}

float Geometric_Kelemen(float a, float NdV, float NdL, float LdV)
{
    return (2 * NdL * NdV) / (1 + LdV);
}

float Geometric_Beckman(float a, float dotValue)
{
    float c = dotValue / ( a * sqrt(1.0f - dotValue * dotValue));

    if ( c >= 1.6f )
    {
        return 1.0f;
    }
    else
    {
        float c2 = c * c;
        return (3.535f * c + 2.181f * c2) / ( 1 + 2.276f * c + 2.577f * c2);
    }
}

float Geometric_Smith_Beckmann(float a, float NdV, float NdL)
{
    return Geometric_Beckman(a, NdV) * Geometric_Beckman(a, NdL);
}

float Geometric_GGX(float a, float dotValue)
{
    float a2 = a * a;
    return (2.0f * dotValue) / (dotValue + sqrt(a2 + ((1.0f - a2) * (dotValue * dotValue))));
}

float Geometric_Smith_GGX(float a, float NdV, float NdL)
{
    return Geometric_GGX(a, NdV) * Geometric_GGX(a, NdL);
}

float Geometric_Smith_Schlick_GGX(float a, float NdV, float NdL)
{
        // Smith schlick-GGX.
    float k = a * 0.5f;
    float GV = NdV / (NdV * (1 - k) + k);
    float GL = NdL / (NdL * (1 - k) + k);

    return GV * GL;
}
float3 Fresnel_None(float3 specularColor)
{
    return specularColor;
}

float3 Fresnel_CookTorrance(float3 specularColor, float3 h, float3 v)
{
    float3 n = (1.0f + sqrt(specularColor)) / (1.0f - sqrt(specularColor));
    float c = saturate(dot(v, h));
    float3 g = sqrt(n * n + c * c - 1.0f);

    float3 part1 = (g - c)/(g + c);
    float3 part2 = ((g + c) * c - 1.0f)/((g - c) * c + 1.0f);

    return max(0.0f.xxx, 0.5f * part1 * part1 * ( 1 + part2 * part2));
}

float Specular_D(float a, float NdH)
{
    return NormalDistribution_BlinnPhong(a, NdH);
#ifdef NDF_BECKMANN
    return NormalDistribution_Beckmann(a, NdH);
#else
#ifdef NDF_GGX
    return NormalDistribution_GGX(a, NdH);
#endif
#endif
}

float3 Specular_F(float3 specularColor, float3 h, float3 v)
{
    return Fresnel_None(specularColor);
#ifdef FRESNEL_SCHLICK
    return Fresnel_Schlick(specularColor, h, v);
#else
#ifdef FRESNEL_COOKTORRANCE
    return Fresnel_CookTorrance(specularColor, h, v);
#endif
#endif
}

float3 Specular_F_Roughness(float3 specularColor, float a, float3 h, float3 v)
{
    // Sclick using roughness to attenuate fresnel.
    return (specularColor + (max(1.0f-a, specularColor) - specularColor) * pow((1 - saturate(dot(v, h))), 5));
#ifdef FRESNEL_NONE
    return Fresnel_None(specularColor);
#else
#ifdef FRESNEL_COOKTORRANCE
    return Fresnel_CookTorrance(specularColor, h, v);
#endif
#endif
}

float Specular_G(float a, float NdV, float NdL, float NdH, float VdH, float LdV)
{
    //return Geometric_Implicit(a, NdV, NdL);

#ifdef GEOMETRIC_NEUMANN
    return Geometric_Neumann(a, NdV, NdL);
#else

#ifdef GEOMETRIC_COOKTORRANCE
    return Geometric_CookTorrance(a, NdV, NdL, NdH, VdH);
#else

#ifdef GEOMETRIC_KELEMEN
    return Geometric_Kelemen(a, NdV, NdL, LdV);
#else

#ifdef GEOMETRIC_SMITH_BECKMANN
    return Geometric_Smith_Beckmann(a, NdV, NdL);
#else

#ifdef GEOMETRIC_SMITH_GGX
    return Geometric_Smith_GGX(a, NdV, NdL);
#else

    return Geometric_Smith_Schlick_GGX(a, NdV, NdL);

#endif
#endif
#endif
#endif
#endif
}

float3 Specular(float3 specularColor, float3 h, float3 v, float3 l, float a, float NdL, float NdV, float NdH, float VdH, float LdV)
{
    return ((Specular_D(a, NdH) * Specular_G(a, NdV, NdL, NdH, VdH, LdV)) * Specular_F(specularColor, v, h) ) / (4.0f * NdL * NdV + 0.0001f);
}

float3 Diffuse(float3 pAlbedo)
{
    return pAlbedo/PI;
}
float3 ComputeLight(float3 albedoColor,float3 specularColor, float3 normal, float roughness, float3 lightPosition, float3 lightColor, float3 lightDir, float3 viewDir)
{
    // Compute some useful values.
    float NdL = saturate(dot(normal, lightDir));
    float NdV = saturate(dot(normal, viewDir));
    float3 h = normalize(lightDir + viewDir);
    float NdH = saturate(dot(normal, h));
    float VdH = saturate(dot(viewDir, h));
    float LdV = saturate(dot(lightDir, viewDir));
    float a = max(0.001f, roughness * roughness);

    float3 cDiff = Diffuse(albedoColor);
    float3 cSpec = Specular(specularColor, h, viewDir, lightDir, a, NdL, NdV, NdH, VdH, LdV);

    return lightColor * NdL * (cDiff * (1.0f - cSpec) + cSpec);
}

float3 DisneyBRDF(float3 base_color, out float3 specular_color, float3 normal, float roughness, float3 lightDir, float3 viewDir, out float3 diffuse)
{
	float NdL = saturate(dot(normal, lightDir));
	float NdV = saturate(dot(normal, viewDir));

	float3 h = normalize(lightDir + viewDir);
	float NdH = saturate(dot(normal, h));
	float VdH = saturate(dot(viewDir, h));
	float LdV = saturate(dot(lightDir, viewDir));
	float LdH = saturate(dot(lightDir, h));

	float max_rough = max(0.0001f, roughness * roughness);

	float luminance = 0.3f * base_color.x + 0.6f * base_color.y + 0.1f * base_color.z;

	float3 tint = luminance > 0.0f ? base_color / luminance : 1.0f.xxx;
	specular_color = lerp(1.0f * 0.08f * lerp(1.0f.xxx, tint, 1.0f) , base_color, 1.0f);
	float3 CSheen = lerp(1.0f.xxx, tint, 1.0f);

	float FL = Fresnel_Schlick(NdL);
	float FV = Fresnel_Schlick(NdV);
	float Fd90 = 0.5f + 2.0f * LdH * LdH * max_rough;
	float Fd = lerp(1.0f, Fd90, FL) * lerp(1.0f, Fd90, FV);

	float Fss90 = LdH * LdH * max_rough;
	float Fss = lerp(1.0f, Fss90, FL) * lerp(1.0f, Fss90, FV);
	float ss = 1.25f * (Fss * (1.0f / (NdL + NdV + 0.0001f) - 0.5f) + 0.5f);

	float aspect = sqrt(1.0f - 0.1f * 0.9f);
	float ax = max(0.001f, sqr(max_rough) / aspect);
	float ay = max(0.001f, sqr(max_rough) * aspect);
	float Ds = 1.f;
	float FH = Fresnel_Schlick(LdH);
	float3 Fs = lerp(specular_color, 1.0f.xxx, FH);
	float roughg = sqr(max_rough*0.5f+0.5f);
	float Gs = smithG_GGX(NdL, roughg) * smithG_GGX(NdV, roughg);

	//sheen
	float3 Fsheen = FH * 1.0f * CSheen;

	//clearcoat
	float Dr = GTR1(NdH, lerp(0.1f, 0.001f, 1.0f)); //gloss variable
	float Fr = lerp(0.04f, 1.0f, FH);
	float Gr = smithG_GGX(NdL, 0.25f) * smithG_GGX(NdV, 0.25f);
	diffuse = ((1.0f/PI) * lerp(Fd, ss, 1.0f /* */) * base_color + Fsheen) * (1.0f - 0.0f);


	return (diffuse);// + Gs * Fs * Ds + 0.25f * 1.0f * Gr * Fr * Dr) * NdL;
}


float4 main(VS_OUTPUT input) : SV_Target
{
	float4 albedo = AlbedoTexture.Sample(sampler0, input.uv);	
	float4 normal = NormalTexture.Sample(sampler0, input.uv);
	float4 depth = DepthTexture.Sample(sampler0, input.uv);

	albedo.rgb = pow(albedo.rgb, 2.2f);

	float roughness = depth.y;
	float metalness = normal.w;

	float3 realAlbedo = albedo.rgb;// - albedo.rgb * metalness;
	float3 realSpecular = lerp(0.03f, albedo.rgb, metalness);



	float4 pos = input.pos / input.pos.w;
	float2 tex_coord = input.uv;
	float x = tex_coord.x * 2.f - 1.f;
	float y = (1.f - tex_coord.y) * 2 - 1;
	float z = depth.x;
	float4 world_pos = float4(x, y, z, 1.f);
	
	world_pos = mul(world_pos, InvertedProjection);
	world_pos = mul(world_pos, InvertedView);

	
	float3 viewDir = normalize(camera_position - world_pos);
	float3 spec = 0.0f.xxx;
	float3 diffuse = 0.0f.xxx;
	float3 light1 = DisneyBRDF(albedo.rgb, spec, normal, roughness, light_direction, viewDir, diffuse);


	float attenuation = 0.001f;

	float3 reflectVector = reflect(-viewDir, normal);
	float mipIndex = roughness * roughness * 8;

	float3 envColor = CubeMap.SampleLevel(sampler0, reflectVector, mipIndex);
	float3 irradiance = 1.f;
	envColor = pow(envColor.rgb, 2.2);
	float3 envFresnel = Specular_F_Roughness(realSpecular, roughness , normal, viewDir);

	attenuation *= 0.1f;
	realAlbedo = saturate(diffuse);

	return float4(attenuation * 1.0 * light1 +  envFresnel*envColor * 1.0 + realAlbedo * irradiance * 0.42f, 1.0f);

};

Engine Tasks:
  Level / World:
    ✔ Quadtree / Octree @done (17-01-29 23:57)
    ✔ Treenode updates entities by themselves. @done (17-01-29 23:57)
    ✔ Remove / Add Nodes dynamically @started @done (17-02-07 14:26)
    ☐ Move entities from node to node with minimum overhead. @paused
      ✔ BUG: Update time of the octree increases overtime the more you call the "InsertDweller" function @critical @done (17-02-07 14:26)
  Entities:
    ☐ Create and edit entities in engine. @low
    ☐ Standardize rotations in engine @high
    ☐ Flag lights that should be able to cast shadows. @low
    ✔ OBB click collision on entities @done (17-01-22 00:59)
      ✔ Add box around entity @done (17-01-18 21:05)
      ✘ Use physics for OBB click collision on entities @cancelled (17-01-18 18:43)
      ✔ Receive callback on clicked entity @done (17-01-18 21:05)
      ✔ Have the box be oriented around the model / entity @done (17-01-18 22:28)
      ✔ Collision Checks are a bit broken on some rotations @done (17-01-22 00:59)
        ✔ Fix it @done (17-01-22 00:59)
    ☐ Entity rotation & physics rotation should be loaded in euler angles
    ☐ When entities save, their rotation is stored as euler angles
    ☐ When entities are edited in the engine, they will change with quaternions 
    ☐ Clickable entities in octree
  Debug UI:
    ✔ Hook up some kind of debug/edit-mode UI (imgui) @done (17-01-19 22:32)
    ✔ Configure imgui @done (17-01-22 00:59)
    ✔ Hook up some relevant variables @done (17-01-22 00:59)
    ☐ Entity Editing @low
  Particles:
    ☐ Custom particle shapes 
    ☐ Emitter System
  Network:
    <http://stackoverflow.com/questions/366257/everything-a-c-developer-should-know-about-network-programming/>
    ☐ Add the network API to the engine and make the engine able to run without Graphics.
    ☐ NetworkComponent for Entities should be setting positions of the other entities.
    ☐ The level / world needs/Should be verified by the server with some kind of hash 
       (network_version + map_name + user_name) or something like that
    ☐ FlatBuffers <https://google.github.io/flatbuffers/>
    ☐ Handshake message
      ☐ Check MTU size of Client
    ☐ Reliability filter
  Shaders:
    Compute Shaders:
       ☐ Experiment with compute shaders
         ☐ Send a buffer of work to the shader
         ☐ read the data on the CPU
  Rendering:
    Resources
    <https://github.com/Basez/Agnostik-Engine/>
    ☐ Abstract
      ☐ All the calls should go through the interface and not through the API.  
      ☐ Remove GetAPI()
    ☐ Resize Message 
    ☐ Finish the current render frame before initiating / removing a main/sub state.
    ☐ Add Vulkan to regular build instead of having its separate build
    ☐ Check if the compile platform is windows for DirectX
    ☐ Post Processing Effects (HDR, Blur, Bloom, ...)
    ☐ Soft Shadows
    ✘ Separate light pass to its own texture @cancelled (17-02-20 13:15)
    ☐ Move directional light to its own shader pass & not when the ambient runs.
    Postprocessing:
      ☐ HDR @started
        ☐ Tonemapping
        ☐ Good fade between dark and bright areas.
        ☐ Artist / Designer controlled exposure boxes
      ☐ Bloom
      ☐ Motion Blur
      ☐ Color Correction
      ☐ Contrast
      ☐ Saturate
  StateStack:
    ✔ Move to engine @done (17-01-29 23:57)
    ☐ Debug State?
    ☐ Keep Rendering through the state, copy current render buffer and just add new commands to it?
  Memory:
    ☐ Investigate Memory Allocators
    ☐ Implement custom memory allocators @high 
      ☐ Linear Allocator
      ☐ Stack Allocator
      ☐ Circle Allocator
    ☐ Rewrite the CommonLib containers 
  Physics:
    ☐ Physics Bodies
      ☐ Mesh
      ☐ Cube
      ☐ Sphere
    ☐ ASync? Calculations on GPU?
  Terrain:
    ☐ Merge the render & physics body into one object
      ☐ Placeholder
  Multi-Threading:
    <https://msdn.microsoft.com/en-us/library/windows/desktop/ms682516(v=vs.85).aspx>
    ☐ Investigate fiber
    ☐ Investigate possible performance gains (not that I need them right now) from internally threading physics
    ☐ Investigate grouping up vertex buffers & index buffers
      ☐ CommandBuffers / RenderCommands
      ☐ A big drawcall instead of several small ones. Context swaps are expensive and can be solved by having a lot of vertices & indices in a single call. 
    ☐ TreeNodes to be threaded?
  I/O:
    ☐ Thread loading of models.
      ☐ Placeholder
CommonLib:
  Math:
    ☐ Quaternion -> Matrix
        ☐ Convert quaternion rotation into matrix
        ☐ Convert matrix rotation into quaternion
  Containers:
    ☐ GrowingArray might be broke
    ☐ Rewrite with the use of custom allocators

